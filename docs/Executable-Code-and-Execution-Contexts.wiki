{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10}}
{{test262|http://hg.ecmascript.org/tests/test262/file/f2b232b08824/test/suite/ch10}}

== {{anchor|x10.1}}可执行代码类型 ==
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.1}}
{{test262|http://hg.ecmascript.org/tests/test262/file/f2b232b08824/test/suite/ch10/10.1}}

一共有三种 ECMA 脚本可执行代码：

* <b id="global-code">全局代码</b>是指被作为 ECMAScript ''[[ES5/program#Program|Program]]'' 处理的源代码文本。一个特定 ''[[ES5/program#Program|Program]]'' 的全局代码不包括作为 ''[[ES5/functions#FunctionBody|FunctionBody]]'' 被解析的源代码文本。
* <b id="eval-code">Eval 代码</b>是指提供给 [[ES5/builtins#x15.1.2.1|eval]] 内置函数的源代码文本。更精确地说，如果传递给 [[ES5/builtins#x15.1.2.1|eval]] 内置函数的参数为一个字符串，该字符串将被作为 ECMA 脚本 ''[[ES5/program#Program|Program]]'' 进行处理。在特定的一次对 [[ES5/builtins#15.1.2.1|eval]] 的调用过程中，[[ES5/builtins#x15.1.2.1|eval]] 代码作为该 ''[[ES5/program#Program|Program]]'' 的[[#global-code|全局代码]]部分。
* <b id="function-code">函数代码</b>是指作为 ''[[ES5/functions#FunctionBody|FunctionBody]]'' 被解析的源代码文本。一个 ''[[ES5/functions#FunctionBody|FunctionBody]]'' 的[[#function-code|函数代码]]不包括作为其嵌套函数的 ''[[ES5/functions#FunctionBody|FunctionBody]]'' 被解析的源代码文本。[[#function-code|函数代码]]同时还特指以构造器方式调用 [[ES5/builtins#x15.3.2|Function]] 内置对象时所提供的源代码文本。更精确地说，调用 [[ES5/builtins#x15.3.2|Function]] 构造器时传递的最后一个参数将被转换为字符串并作为 ''[[ES5/functions#FunctionBody|FunctionBody]]'' 使用。如果调用 [[ES5/builtins#x15.3.2|Function]] 构造器时，传递了一个以上的参数，除最后一个参数以外的其他参数都将转换为字符串，并以逗号作为分隔符连接在一起成为一个字符串，该字符串被解析为 ''[[ES5/functions#FormalParameterList|FormalParameterList]]'' 供由最后一个参数定义的 ''[[ES5/functions#FunctionBody|FunctionBody]]'' 使用。初始化 [[ES5/builtins#x15.3.2|Function]] 对象时所提供的函数代码，并不包括作为其嵌套函数的 ''[[ES5/functions#FunctionBody|FunctionBody]]'' 被解析的源代码文本。


==== {{anchor|x10.1.1}}{{anchor|strict-mode-code}}严格模式下的代码 ====
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.1.1}}

一个 ECMA 脚本程序的语法单元可以使用非严格或严格模式下的语法及语义进行处理。当使用严格模式进行处理时，以上三种代码将被称为严格全局代码、严格 [[ES5/builtins#x15.1.2.1|eval]] 代码和严格函数代码。当符合以下条件时，代码将被解析为严格模式下的代码：

* 当[[#global-code|全局代码]]以[[ES5/program#x14.1|指令序言]]开始，且该[[ES5/program#x14.1|指令序言]]包含一个使用[[ES5/program#x14.1|严格模式指令]]（参考 [[ES5/program#x14.1|14.1 章]]）时，即为严格全局代码。
* 当 [[#eval-code|Eval 代码]]以[[ES5/program#x14.1|指令序言]]开始，且该[[ES5/program#x14.1|指令序言]]包含一个使用[[ES5/program#x14.1|严格模式指令]]时；或者在[[#strict-mode-code|严格模式下的代码]]中通过直接调用 [[ES5/builtins#x15.1.2.1.1|eval 函数]]（参考 [[ES5/builtins#x15.1.2.1.1|15.1.2.1.1 章]]）时，即为严格 [[ES5/builtins#x15.1.2.1|eval]] 代码。
* 当一个 ''[[ES5/functions#FunctionDeclaration|FunctionDeclaration]]''、''[[ES5/functions#FunctionExpression|FunctionExpression]]'' 或 ''[[ES5/expressions#inlinePropertyAssignment|PropertyAssignment]]'' 访问器处在一段[[#strict-mode-code|严格模式下的代码]]中，或其函数代码以[[ES5/program#x14.1|指令序言]]开始，且该[[ES5/program#x14.1|指令序言]]包含一个使用严格模式的[[ES5/program#x14.1|指令序言]]时，该[[#function-code|函数代码]]即为严格函数代码。
* 当调用内置的 [[ES5/builtins#x15.3.2|Function]] 构造器时，如果最后一个参数所表达的字符串在作为 ''[[ES5/functions#FunctionBody|FunctionBody]]'' 处理时以指令序言开始，且该[[ES5/program#x14.1|指令序言]]包含一个使用严格模式的指令，则该[[#function-code|函数代码]]即为严格函数代码。


== {{anchor|lexical-environments}}{{anchor|x10.2}}词法环境 ==
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.2}}
{{test262|http://hg.ecmascript.org/tests/test262/file/f2b232b08824/test/suite/ch10/10.2}}
{{anchor|lexical-environment}}'''词法环境'''是一个用于定义特定变量和函数[[ES5/lexical#x7.6|标识符]]在 ECMAScript 代码的词法嵌套结构上关联关系的[[ES5/types#specification-type|规范类型]]。一个词法环境由一个[[#environment-record|环境记录项]]和可能为空的[[#outer-environment-reference|外部词法环境引用]]构成。通常词法环境会与 ECMAScript 代码诸如 ''[[ES5/functions#FunctionDeclaration|FunctionDeclaration]]''、''[[ES5/statements#WithStatement|WithStatement]]'' 或者 ''[[ES5/statements#TryStatement|TryStatement]]'' 的 ''[[ES5/statements#Catch|Catch]]'' 块这样的特定句法结构相联系，且类似代码每次执行都会有一个新的'''词法环境'''被创建出来。

[[#environment-record|环境记录项]]记录了在其关联的词法环境范围中创建的[[ES5/lexical#x7.6|标识符]]绑定。

{{anchor|outer-environment-reference}}'''外部词法环境引用'''用于表示词法环境的逻辑嵌套关系模型。（内部）词法环境的外部引用是逻辑上包含内部词法环境的词法环境。外部词法环境自然也可能有多个内部词法环境。例如，如果一个 ''[[ES5/functions#FunctionDeclaration|FunctionDeclaration]]'' 包含两个嵌套的 ''[[ES5/functions#FunctionDeclaration|FunctionDeclaration]]''，那么每个内嵌函数的词法环境都是外部函数本次执行所产生的词法环境。

--[[User:Undefined|Undefined]] ([[User talk:Undefined|talk]]) 04:46, 28 January 2014 (UTC)词法环境和环境记录项是纯粹的规范机制，而不需要 ECMAScript 的实现保持一致。ECMAScript 程序不可能直接访问或者更改这些值。


=== {{anchor|x10.2.1}}{{anchor|environment-record}}环境记录项 ===
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.2.1}}

{{anchor|declarative-environment-record}}{{anchor|object-environment-record}}在本标准中，共有两类环境记录项：[[#x10.2.1.1|声明式环境记录项]]和[[#x10.2.1.2|对象式环境记录项]]。[[#x10.2.1.1|声明式环境记录项]]用于定义那些将[[ES5/lexical#x7.6|标识符]]与语言值直接绑定的 ECMA 脚本语法元素，例如 ''[[ES5/functions#FunctionDeclaration|FunctionDeclaration]]''、''[[ES5/functions#VariableDeclaration|VariableDeclaration]]'' 以及 ''[[ES5/statements#Catch|Catch]]'' 语句。[[#x10.2.1.2|对象式环境记录项]]用于定义那些将[[ES5/lexical#x7.6|标识符]]与具体对象的属性绑定的 ECMA 脚本元素，例如 ''[[ES5/program#Program|Program]]'' 以及 ''[[ES5/statements#WithStatement|WithStatement]]'' 表达式。

出于标准规范的目的，可以将环境记录项理解为面向对象中的一个简单继承结构，其中环境记录项是一个抽象类，有两个具体实现类，分别为[[#x10.2.1.1|声明式环境记录项]]和[[#x10.2.1.2|对象式环境记录项]]。抽象类包含了 '''表17''' 所描述的抽象方法定义，针对每一个具体实现类，每个抽象方法都有不同的具体算法。

{| border="1" cellpadding="5" style="border-collapse:collapse;" align="center"
|+ '''表17 - 环境记录项的抽象方法'''
|- style="background:#EEE;"
| nowrap | 方法 
| 作用 
|-
| nowrap |{{anchor|HasBinding}}'''HasBinding'''(<var>N</var>) {{extra note|#DER-HasBinding|声明式}} {{extra note|#OER-HasBinding|对象式}}
| 判断环境记录项是否包含对某个[[ES5/lexical#x7.6|标识符]]的绑定。如果包含该绑定则返回 '''true'''，反之返回 '''false'''。其中字符串 <var>N</var> 是[[ES5/lexical#x7.6|标识符]]文本。
|-
! nowrap |{{anchor|CreateMutableBinding}}'''CreateMutableBinding'''(<var>N</var>, <var>D</var>) {{extra note|#DER-CreateMutableBinding|声明式}} {{extra note|#OER-CreateMutableBinding|对象式}}
| 在环境记录项中创建一个新的可变绑定。其中字符串 <var>N</var> 指定绑定名称。如果可选参数 <var>D</var> 的值为 '''true'''，则该绑定在后续操作中可以被删除。
|-
| nowrap |{{anchor|SetMutableBinding}}'''SetMutableBinding'''(<var>N</var>, <var>V</var>, <var>S</var>) {{extra note|#DER-SetMutableBinding|声明式}} {{extra note|#OER-SetMutableBinding|对象式}}
| 在环境记录项中设置一个已经存在的绑定的值。其中字符串 <var>N</var> 指定绑定名称。<var>V</var> 用于指定绑定的值，可以是任何 ECMA 脚本[[ES5/types#language-type|语言的类型]]。<var>S</var> 是一个布尔类型的标记，当 <var>S</var> 为 '''true''' 并且该绑定不允许赋值时，则抛出一个 '''TypeError''' 异常。<var>S</var> 用于指定是否为严格模式。
|-
| nowrap |{{anchor|GetBindingValue}}'''GetBindingValue'''(<var>N</var>, <var>S</var>) {{extra note|#DER-GetBindingValue|声明式}} {{extra note|#OER-GetBindingValue|对象式}}
| 返回环境记录项中一个已经存在的绑定的值。其中字符串 <var>N</var> 指定绑定的名称。<var>S</var> 用于指定是否为严格模式。如果 <var>S</var> 的值为 '''true''' 并且该绑定不存在或未初始化，则抛出一个 '''ReferenceError''' 异常。
|-
| nowrap |{{anchor|DeleteBinding}}'''DeleteBinding'''(<var>N</var>) {{extra note|#DER-DeleteBinding|声明式}} {{extra note|#OER-DeleteBinding|对象式}}
| 从环境记录项中删除一个绑定。其中字符串 <var>N</var> 指定绑定的名称。如果 <var>N</var> 指定的绑定存在，将其删除并返回 '''true'''。如果绑定存在但无法删除则返回 '''false'''。如果绑定不存在则返回 '''true'''。
|-
| nowrap |{{anchor|ImplicitThisValue}}'''ImplicitThisValue'''() {{extra note|#DER-ImplicitThisValue|声明式}} {{extra note|#OER-ImplicitThisValue|对象式}}
| 当从该环境记录项的绑定中获取一个函数对象并且调用时，该方法返回该函数对象使用的 '''this''' 对象的值。
|}


==== {{anchor|x10.2.1.1}}声明式环境记录项 ====
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.2.1.1}}

每个[[#x10.2.1.1|声明式环境记录项]]都与一个包含变量和（或）函数声明的 ECMA 脚本的程序作用域相关联。[[#x10.2.1.1|声明式环境记录项]]用于绑定作用域内定义的一系列[[ES5/lexical#x7.6|标识符]]。

除了所有环境记录项都支持的可变绑定外，[[#x10.2.1.1|声明式环境记录项]]还提供不可变绑定。
在<b id="immutable-binding">不可变绑定</b>中，一个[[ES5/lexical#x7.6|标识符]]与它的值之间的关联关系建立之后，就无法改变。创建和初始化不可变绑定是两个独立的过程，因此类似的绑定可以处在已初始化阶段或者未初始化阶段。除了环境记录项定义的抽象方法外，[[#x10.2.1.1|声明式环境记录项]]还支持 '''表18''' 中列出的方法：

{| border="1" cellpadding="5" style="border-collapse:collapse;" align="center"
|+ '''表18 - 声明式环境记录项的额外方法'''
|- style="background:#EEE;"
| nowrap | 方法 
| 作用 
|-
| nowrap | [[#CreateImmutableBinding|CreateImmutableBinding]](<var>N</var>)
| 在环境记录项中创建一个未初始化的[[#immutable-binding|不可变绑定]]。其中字符串 <var>N</var> 指定绑定名称。
|-
| nowrap | [[#InitializeImmutableBinding|InitializeImmutableBinding]](<var>N</var>, <var>V</var>)
| 在环境记录项中设置一个已经创建但未初始化的[[#immutable-binding|不可变绑定]]的值。其中字符串 <var>N</var> 指定绑定名称。<var>V</var> 用于指定绑定的值，可以是任何 ECMA 脚本[[ES5/types#language-type|语言的类型]]。
|}

环境记录项定义的方法的具体行为将由以下算法给予描述。


===== {{anchor|x10.2.1.1.1}}{{anchor|DER-HasBinding}}HasBinding(N) =====
{{eng ver|http://ecma-international.org/ecma-262/5.1/#10.2.1.1.1}}

[[#x10.2.1.1|声明式环境记录项]]的 '''HasBinding''' 具体方法用于简单地判断作为参数的[[ES5/lexical#x7.6|标识符]]是否是当前对象绑定的[[ES5/lexical#x7.6|标识符]]之一：

# 令 <var>envRec</var> 为函数调用时对应的[[#x10.2.1.1|声明式环境记录项]]。
# 如果 <var>envRec</var> 有一个名称为 <var>N</var> 的绑定，返回 '''true'''。
# 如果没有该绑定，返回 '''false'''。


===== {{anchor|x10.2.1.1.2}}{{anchor|DER-CreateMutableBinding}}CreateMutableBinding(N, D) =====
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.2.1.1.2}}

[[#x10.2.1.1|声明式环境记录项]]的 '''CreateMutableBinding''' 具体方法会创建一个名称为 <var>N</var> 的绑定，并初始化其值为 '''undefined'''。方法调用时，当前环境记录项中不能存在 <var>N</var> 的绑定。如果调用时提供了布尔类型的参数 <var>D</var> 且其值为 '''true'''，则新建的绑定被标记为可删除。

# 令 <var>envRec</var> 为函数调用时对应的[[#x10.2.1.1|声明式环境记录项]]。
# 执行断言：<var>envRec</var> 没有 <var>N</var> 的绑定。
# 在 <var>envRec</var> 中为 <var>N</var> 创建一个可变绑定，并将绑定的值设置为 '''undefined'''。如果 <var>D</var> 为 '''true''' 则新创建的绑定可在后续操作中通过调用 [[#DER-DeleteBinding|DeleteBinding]] 删除。


===== {{anchor|x10.2.1.1.3}}{{anchor|DER-SetMutableBinding}}SetMutableBinding(N, V, S) =====
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.2.1.1.3}}

[[#x10.2.1.1|声明式环境记录项]]的 '''SetMutableBinding''' 具体方法尝试将当前名称为参数 <var>N</var> 的绑定的值修改为参数 <var>V</var> 指定的值。方法调用时，必须存在 <var>N</var> 的绑定。如果该绑定为不可变绑定，并且 <var>S</var> 的值为 '''true'''，则抛出一个 '''TypeError''' 异常。

# 令 <var>envRec</var> 为函数调用时对应的[[#x10.2.1.1|声明式环境记录项]]。
# 执行断言：<var>envRec</var> 必须有 <var>N</var> 的绑定。
# 如果 <var>envRec</var> 中 <var>N</var> 的绑定为可变绑定，则将其值修改为 <var>V</var>。
# 否则该操作会尝试修改一个不可变绑定的值，因此如果 <var>S</var> 的值为 '''true'''，则抛出一个 '''TypeError''' 异常。


===== {{anchor|x10.2.1.1.4}}{{anchor|DER-GetBindingValue}}GetBindingValue(N, S) =====
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.2.1.1.4}}

[[#x10.2.1.1|声明式环境记录项]]的 '''GetBindingValue''' 具体方法简单地返回名称为参数 <var>N</var> 的绑定的值。方法调用时，该绑定必须存在。如果 <var>S</var> 的值为 '''true''' 且该绑定是一个未初始化的不可变绑定，则抛出一个 '''ReferenceError''' 异常。

# 令 <var>envRec</var> 为函数调用时对应的[[#x10.2.1.1|声明式环境记录项]]。
# 执行断言：<var>envRec</var> 必须有 <var>N</var> 的绑定。
# 如果 <var>envRec</var> 中 <var>N</var> 的绑定是一个未初始化的不可变绑定，则：
## 如果 <var>S</var> 为 '''false'''，返回 '''undefined'''，否则抛出一个 '''ReferenceError''' 异常。
# 否则返回 <var>envRec</var> 中与 <var>N</var> 绑定的值。


===== {{anchor|x10.2.1.1.5}}{{anchor|DER-DeleteBinding}}DeleteBinding(N) =====
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.2.1.1.5}}

[[#x10.2.1.1|声明式环境记录项]]的 '''DeleteBinding''' 具体方法只能删除显示指定可被删除的那些绑定。

# 令 <var>envRec</var> 为函数调用时对应的[[#x10.2.1.1|声明式环境记录项]]。
# 如果 <var>envRec</var> 不包含名称为 <var>N</var> 的绑定，返回 '''true'''。
# 如果 <var>envRec</var> 中 <var>N</var> 的绑定不能删除，返回 '''false'''。
# 移除 <var>envRec</var> 中 <var>N</var> 的绑定。
# 返回 '''true'''。


===== {{anchor|x10.2.1.1.6}}{{anchor|DER-ImplicitThisValue}}ImplicitThisValue() =====
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.2.1.1.6}}

[[#x10.2.1.1|声明式环境记录项]]永远将 '''undefined''' 作为其 '''ImplicitThisValue''' 返回。

# 返回 '''undefined'''。


===== {{anchor|x10.2.1.1.7}}{{anchor|CreateImmutableBinding}}CreateImmutableBinding(N) =====
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.2.1.1.7}}

[[#x10.2.1.1|声明式环境记录项]]的 '''CreateImmutableBinding''' 具体方法会创建一个不可变绑定，其名称为 <var>N</var> 且初始化其值为 '''undefined'''。调用方法时，该环境记录项中不得存在 <var>N</var> 的绑定。

# 令 <var>envRec</var> 为函数调用时对应的[[#x10.2.1.1|声明式环境记录项]]。
# 执行断言：<var>envRec</var> 不存在 <var>N</var> 的绑定。
# 在 <var>envRec</var> 中为 <var>N</var> 创建一个不可变绑定，并记录为未初始化。


===== {{anchor|x10.2.1.1.8}}{{anchor|InitializeImmutableBinding}}InitializeImmutableBinding(N, V) =====
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.2.1.1.8}}

[[#x10.2.1.1|声明式环境记录项]]的 '''InitializeImmutableBinding''' 具体方法用于将当前名称为参数 <var>N</var> 的绑定的值修改为参数 <var>V</var> 指定的值。方法调用时，必须存在 <var>N</var> 对应的未初始化的不可变绑定。

# 令 <var>envRec</var> 为函数调用时对应的[[#x10.2.1.1|声明式环境记录项]]。
# 执行断言：<var>envRec</var> 存在一个与 <var>N</var> 对应的未初始化的不可变绑定。
# 在 <var>envRec</var> 中将 <var>N</var> 的绑定的值设置为 <var>V</var>。
# 在 <var>envRec</var> 中将 <var>N</var> 的不可变绑定记录为已初始化。


==== {{anchor|x10.2.1.2}}{{anchor|binding-object}}对象式环境记录项 ====
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.2.1.2}}

每一个[[#x10.2.1.2|对象式环境记录项]]都有一个关联的对象，这个对象被称作'''绑定对象 '''。[[#x10.2.1.2|对象式环境记录项]]直接将一系列[[ES5/lexical#x7.6|标识符]]与其'''绑定对象'''的属性名称建立一一对应关系。不符合 ''[[ES5/lexical#IdentifierName|IdentifierName]]'' 的属性名不会作为绑定的[[ES5/lexical#x7.6|标识符]]使用。无论是对象自身的，还是继承的属性都会作为绑定，无论该属性的 [[ES5/types#Enumerable|<nowiki>[[Enumerable]]</nowiki>]] 特性的值是什么。由于对象的属性可以动态的增减，因此[[#x10.2.1.2|对象式环境记录项]]所绑定的[[ES5/lexical#x7.6|标识符]]集合也会隐匿地变化，这是增减'''绑定对象'''的属性而产生的副作用。通过以上描述的副作用而建立的绑定，均被视为可变绑定，即使该绑定对应的属性的 [[ES5/types#Writable|<nowiki>[[Writable]]</nowiki>]] 特性的值为 '''false'''。[[#x10.2.1.2|对象式环境记录项]]没有[[#immutable-binding|不可变绑定]]。

[[#x10.2.1.2|对象式环境记录项]]可以通过配置的方式，将其绑定对象合为函数调用时的隐式 '''this''' 对象的值。这一功能用于规范  ''[[ES5/statements#WithStatement|WithStatement]]'' 引入的绑定行为。该行为通过[[#x10.2.1.2|对象式环境记录项]]中布尔类型的 <var>provideThis</var> 值控制，默认情况下，<var>provideThis</var> 的值为 '''false'''。

环境记录项定义的方法的具体行为将由以下算法给予描述。


===== {{anchor|x10.2.1.2.1}}{{anchor|OER-HasBinding}}HasBinding(N) =====
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.2.1.2.1}}

[[#x10.2.1.2|对象式环境记录项]]的 '''HasBinding''' 具体方法判断其关联的[[#binding-object|绑定对象]]是否有名为 <var>N</var> 的属性：

# 令 <var>envRec</var> 为函数调用时对应的[[#x10.2.1.1|声明式环境记录项]]。
# 令 <var>bindings</var> 为 <var>envRec</var> 的[[#binding-object|绑定对象]]。
# 以 <var>N</var> 为属性名，调用 <var>bindings</var> 的 [[ES5/types#HasProperty|<nowiki>[[HasProperty]]</nowiki>]] 内部方法，并返回调用的结果。


===== {{anchor|x10.2.1.2.2}}{{anchor|OER-CreateMutableBinding}}CreateMutableBinding(N, D) =====
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.2.1.2.2}}

[[#x10.2.1.2|对象式环境记录项]]的 [[#OER-CreateMutableBinding|CreateMutableBinding]]具体方法会在其关联的[[#binding-object|绑定对象]]上创建一个名称为 <var>N</var> 的属性，并初始化其值为 '''undefined'''。调用方法时，[[#binding-object|绑定对象]]不得包含名称为 <var>N</var> 的属性。如果调用方法时提供了布尔类型的参数 <var>D</var> 且其值为 '''true'''，则设置新创建的属性的 [[ES5/types#Configurable|<nowiki>[[Configurable]]</nowiki>]] 特性的值为 '''true'''，否则设置为 '''false'''。

# 令 <var>envRec</var> 为函数调用时对应的[[#x10.2.1.1|声明式环境记录项]]。
# 令 <var>bindings</var> 为 <var>envRec</var> 的[[#binding-object|绑定对象]]。
# 执行断言：以 <var>N</var> 为属性名，调用 <var>bindings</var> 的 [[ES5/types#HasProperty|<nowiki>[[HasProperty]]</nowiki>]] 内部方法，调用的结果为 '''false'''。
# 如果 <var>D</var> 的值为 '''true'''，则令 <var>configValue</var> 的值为 '''true'''，否则令 <var>configValue</var> 的值为 '''false'''。
# 以 <var>N</var>、属性描述符 {<nowiki>[[Value]]</nowiki>:'''undefined''', <nowiki>[[Writable]]</nowiki>: '''true''', <nowiki>[[Enumerable]]</nowiki>: '''true''' , <nowiki>[[Configurable]]</nowiki>: <var>configValue</var>} 和布尔值 '''true''' 为参数，调用 <var>bindings</var> 的 [[ES5/types#DefineOwnProperty|<nowiki>[[DefineOwnProperty]]</nowiki>]] 内部方法。


===== {{anchor|x10.2.1.2.3}}{{anchor|OER-SetMutableBinding}}SetMutableBinding(N, V, S) =====
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.2.1.2.3}}

[[#x10.2.1.2|对象式环境记录项]]的 '''SetMutableBinding''' 具体方法会尝试设置其关联的[[#binding-object|绑定对象]]中名为 <var>N</var> 的属性的值为 <var>V</var>。方法调用时，[[#binding-object|绑定对象]]中应当存在该属性，如果该属性不存在或属性不可写，则根据 <var>S</var> 参数的值来执行错误处理。

# 令 <var>envRec</var> 为函数调用时对应的[[#x10.2.1.1|声明式环境记录项]]。
# 令 <var>bindings</var> 为 <var>envRec</var> 的[[#binding-object|绑定对象]] 
# 以 <var>N</var>、<var>V</var> 和 <var>S</var> 为参数，调用 <var>bindings</var> 的 [[ES5/types#Put|<nowiki>[[Put]]</nowiki>]] 内部方法。


===== {{anchor|x10.2.1.2.4}}{{anchor|OER-GetBindingValue}}GetBindingValue(N, S) =====
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.2.1.2.4}}

[[#x10.2.1.2|对象式环境记录项]]的 '''GetBindingValue''' 具体方法返回其关联的[[#binding-object|绑定对象]]中名为 <var>N</var> 的属性的值。方法调用时，[[#binding-object|绑定对象]]中应当存在该属性，如果该属性不存在，则方法的返回值由 <var>S</var> 参数决定：

# 令 <var>envRec</var> 为函数调用时对应的[[#x10.2.1.1|声明式环境记录项]]。
# 令 <var>bindings</var> 为 <var>envRec</var> 的[[#binding-object|绑定对象]]
# 以 <var>N</var> 为属性名，调用 <var>bindings</var> 的 [[ES5/types#HasProperty|<nowiki>[[HasProperty]]</nowiki>]] 内部方法，并令 <var>value</var> 为调用的结果。
# 如果 <var>value</var> 的值为 '''false'''，则：
## 如果 <var>S</var> 的值为 '''false'''，则返回 '''undefined'''，否则抛出一个 '''ReferenceError''' 异常。
# 以 <var>N</var> 为参数，调用 <var>bindings</var> 的 [[ES5/types#Get|<nowiki>[[Get]]</nowiki>]] 内部方法，并返回调用的结果。


===== {{anchor|x10.2.1.2.5}}{{anchor|OER-DeleteBinding}}DeleteBinding(N) =====
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.2.1.2.5}}

[[#x10.2.1.2|对象式环境记录项]]的 '''DeleteBinding''' 具体方法只能用于删除其关联的[[#binding-object|绑定对象]]上 [[ES5/types#Configurable|<nowiki>[[Configurable]]</nowiki>]] 特性的值为 '''true''' 的属性所对应的绑定。

# 令 <var>envRec</var> 为函数调用时对应的[[#x10.2.1.1|声明式环境记录项]]。
# 令 <var>bindings</var> 为 <var>envRec</var> 的[[#binding-object|绑定对象]]
# 以 <var>N</var> 和布尔值 '''false''' 为参数，调用 <var>bindings</var> 的 [[ES5/types#Delete|<nowiki>[[Delete]]</nowiki>]] 内部方法。


===== {{anchor|x10.2.1.2.6}}{{anchor|OER-ImplicitThisValue}}ImplicitThisValue() =====
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.2.1.2.6}}

[[#x10.2.1.2|对象式环境记录项]]的 '''ImplicitThisValue''' 通常返回 '''undefined'''，除非其 <var>provideThis</var> 标识的值为 '''true'''。

# 令 <var>envRec</var> 为函数调用时对应的[[#object-environment-record|对象式环境记录项]]。
# 如果 <var>envRec</var> 的 <var>provideThis</var> 标识的值为 '''true'''，返回 <var>envRec</var> 的[[#binding-object|绑定对象]]。
# 否则返回 '''undefined'''。


=== {{anchor|x10.2.2}}词法环境的运算 ===
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.2.2}}

在本标准中，以下抽象运算将被用于操作环境记录项：


==== {{anchor|x10.2.2.1}}{{anchor|GetIdentifierReference}}GetIdentifierReference(lex, name, strict) ====
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.2.2.1}}

当调用 '''GetIdentifierReference''' 抽象运算时，需要指定一个[[#lexical-environment|词法环境]] <var>lex</var>，一个[[ES5/lexical#x7.6|标识符]]字符串 <var>name</var> 以及一个布尔型标识 <var>strict</var>。<var>lex</var> 的值可以为 '''null'''。当调用该运算时，按以下步骤进行：

# 如果 <var>lex</var> 的值为 '''null'''，则：
## 返回一个类型为[[ES5/types#Reference|引用]]的对象，其基值为 '''undefined'''，引用的名称为 <var>name</var>，严格模式标识的值为 <var>strict</var>。
# 令 <var>envRec</var> 为 <var>lex</var> 的[[#environment-record|环境数据]]。
# 以 <var>name</var> 为参数 <var>N</var>，调用 <var>envRec</var> 的 {{toanchor|HasBinding}}(<var>N</var>) 具体方法，并令 <var>exists</var> 为调用的结果。
# 如果 <var>exists</var> 为 '''true'''，则：
## 返回一个类型为[[ES5/types#Reference|引用]]的对象，其基值为 <var>envRec</var>，引用的名称为 <var>name</var>，严格模式标识的值为 <var>strict</var>。
# 否则：
## 令 <var>outer</var> 为 <var>lex</var> 的[[#outer-environment-reference|外部环境引用]]。
## 以 <var>outer</var>、<var>name</var> 和 <var>strict</var> 为参数，调用 '''GetIdentifierReference'''，并返回调用的结果。


==== {{anchor|x10.2.2.2}}{{anchor|NewDeclarativeEnvironment}}NewDeclarativeEnvironment(E) ====
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.2.2.2}}

当调用 '''NewDeclarativeEnvironment''' 抽象运算时，需指定一个[[#lexical-environment|词法环境]] <var>E</var>，其值可以为 '''null'''，此时按以下步骤进行：

# 令 <var>env</var> 为一个新建的[[#lexical-environment|词法环境]]。
# 令 <var>envRec</var> 为一个新建的[[#declarative-environment-record|声明式环境数据]]，该[[#environment-record|环境数据]]不包含任何绑定。
# 令 <var>env</var> 的[[#environment-record|环境数据]]为 <var>envRec</var>。
# 令 <var>env</var> 的[[#outer-environment-reference|外部词法环境引用]]至 <var>E</var>。
# 返回 <var>env</var>。


==== {{anchor|x10.2.2.3}}{{anchor|NewObjectEnvironment}}NewObjectEnvironment(O, E) ====
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.2.2.3}}

当调用 '''NewObjectEnvironment''' 抽象运算时，需指定一个对象 <var>O</var> 及一
个[[#lexical-environment|词法环境]] <var>E</var>（其值可以为 '''null'''），此时按以下步骤进行：

# 令 <var>env</var> 为一个新建的[[#lexical-environment|词法环境]]。
# 令 <var>envRec</var> 为一个新建的[[#object-environment-record|对象环境数据]]，该[[#environment-record|环境数据]]包含 <var>O</var> 作为绑定对象。
# 令 <var>env</var> 的[[#environment-record|环境数据]]为 <var>envRec</var>。
# 令 <var>env</var> 的[[#outer-environment-reference|外部词法环境引用]]至 <var>E</var>。
# 返回 <var>env</var>。


=== {{anchor|x10.2.3}}{{anchor|the-global-environment}}全局环境 ===
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.2.3}}

'''全局环境'''是一个唯一的[[#lexical-environment|词法环境]]，它在任何 ECMA 脚本的代码执行前创建。全局环境的[[#environment-record|环境数据]]是一个[[#object-environment-record|对象环境数据]]，该环境数据使用[[ES5/builtins#x15.1|全局对象]]（[[ES5/builtins#x15.1|15.1]]）作为[[#binding-object|绑定对象]]。全局环境的[[#outer-environment-reference|外部环境引用]]为 '''null'''。

在 ECMA 脚本的代码执行过程中，可能会向[[ES5/builtins#x15.1|全局对象]]添加额外的属性，也可能修改其初始属性的值。


== {{anchor|x10.3}}{{anchor|execution-contexts}}执行环境 ==
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.3}}
{{test262|http://hg.ecmascript.org/tests/test262/file/f2b232b08824/test/suite/ch10/10.3}}

当控制器转入 ECMA 脚本的可执行代码时，控制器会进入一个执行环境。当前活动的多个执行环境在逻辑上形成一个栈结构。该逻辑栈的最顶层的执行环境称为当前运行的执行环境。任何时候，当控制器从当前运行的执行环境相关的可执行代码转入与该执行环境无关的可执行代码时，会创建一个新的执行环境。新建的这个执行环境会推入栈中，成为当前运行的执行环境。

执行环境包含所有用于追踪与其相关的代码的执行进度的状态。精确地说，每个执行环境包含如 '''表19''' 列出的组件。

{| border="1" cellpadding="5" style="border-collapse:collapse;" align="center"
|+ '''表19 — 执行环境的状态组件'''
|- style="background:#EEE;"
| nowrap | 组件 
| 作用目的 
|-
| nowrap | {{anchor|LexicalEnvironment}}词法环境组件
| 指定一个[[#lexical-environment|词法环境]]对象，用于解析该执行环境内的代码创建的[[ES5/lexical#x7.6|标识符]]引用。
|-
| nowrap | {{anchor|VariableEnvironment}}变量环境组件
| 指定一个[[#lexical-environment|词法环境]]对象，其环境数据用于保存由该执行环境内的代码通过 ''[[ES5/statements#VariableStatement|VariableStatement]]'' 和 ''[[ES5/functions#FunctionDeclaration|FunctionDeclaration]]'' 创建的绑定。
|-
| nowrap | {{anchor|ThisBinding}}this 绑定
| 指定该执行环境内的 ECMA 脚本代码中 '''this''' 关键字所关联的值。
|}

其中执行环境的[[#LexicalEnvironment|词法环境组件]]和[[#VariableEnvironment|变量环境组件]]始终为[[#lexical-environment|词法环境]]对象。当创建一个执行环境时，其[[#LexicalEnvironment|词法环境组件]]和[[#VariableEnvironment|变量环境组件]]最初是同一个值。在该执行环境相关联的代码的执行过程中，[[#VariableEnvironment|变量环境组件]]永远不变，而[[#LexicalEnvironment|词法环境组件]]有可能改变。

在本标准中，通常情况下，只有正在运行的执行环境（执行环境栈里的最顶层对象）会被算法直接修改。因此当遇到“'''词法环境组件'''”、“'''变量环境组件'''”、“'''this 绑定组件'''”这三个术语时，指的是正在运行的执行环境的对应组件。

执行环境是一个纯粹的标准机制，并不代表任何 ECMA 脚本实现的工件。在 ECMA 脚本程序中是不可能访问到执行环境的。


==== {{anchor|x10.3.1}}{{anchor|identifier-resolution}}标识符解析 ====
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.3.1}}

'''标识符解析'''是指使用正在运行的执行环境中的[[#LexicalEnvironment|词法环境组件]]，通过一个 ''[[ES5/lexical#Identifier|Identifier]]'' 获得其对应的绑定的过程。在 ECMA 脚本代码执行过程中，''[[ES5/expressions#inlinePrimaryExpression|PrimaryExpression]]'' ''':''' ''[[ES5/lexical#Identifier|Identifier]]'' 这一语法产生式将按以下算法进行解释执行：

# 令 <var>env</var> 为正在运行的执行环境的 [[#LexicalEnvironment|词法环境组件]]。
# 如果正在解释执行的语法产生式处在[[#strict-mode-code|严格模式下的代码]]中，则仅 <var>strict</var> 的值为 '''true'''，否则令 <var>strict</var> 的值为 '''false'''。
# 以 <var>env</var>、''[[ES5/lexical#Identifier|Identifier]]'' 和 <var>strict</var> 为参数，调用 [[#GetIdentifierReference|GetIdentifierReference]] 函数，并返回调用的结果。

解释执行一个[[ES5/lexical#x7.6|标识符]]得到的结果必定是[[ES5/types#Reference|引用类型]]的对象，且其引用名属性的值与 ''[[ES5/lexical#Identifier|Identifier]]'' 字符串相等。


== {{anchor|x10.4}}建立执行环境 ==
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.4}}
{{test262|http://hg.ecmascript.org/tests/test262/file/f2b232b08824/test/suite/ch10/10.4}}

解释执行[[#global-code|全局代码]]或使用 [[ES5/builtins#x15.1.2.1|eval]] 函数输入的代码会创建并进入一个新的执行环境。每次调用 ECMA 脚本代码定义的函数（[[ES5/functions#Call-impl|13.2.1]]）也会建立并进入一个新的执行环境，即便函数是自身递归调用的。每一次 [[ES5/statements#ReturnStatement|return]] 都会退出一个执行环境。抛出异常也可退出一个或多个执行环境。

当控制流进入一个执行环境时，会设置该执行环境的 [[#ThisBinding|this 绑定组件]]，定义[[#VariableEnvironment|变量环境]]和初始[[#LexicalEnvironment|词法环境]]，并执行[[#declaration-binding-instantiation|声明式绑定初始化]]过程。以上这些步骤的严格执行方式由进入的代码的类型决定。


=== {{anchor|x10.4.1}}{{anchor|entering-global-code}}进入全局代码 ===
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.4.1}}

当控制流进入[[#global-code|全局代码]]的执行环境时，执行以下步骤：

# 按 [[#initialize-global-context|10.4.1.1]] 描述的方案，使用[[#global-code|全局代码]]初始化执行环境。
# 按 [[#declaration-binding-instantiation|10.5]] 描述的方案，使用[[#global-code|全局代码]]执行[[#declaration-binding-instantiation|声明式绑定初始化]]化步骤。


==== {{anchor|initialize-global-context}}{{anchor|x10.4.1.1}}初始化全局执行环境 ====
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.4.1.1}}

以下步骤描述 ECMA 脚本的全局执行环境 '''C''' {{extra note||这个“C”大概是“ECMA脚本的全局执行环境”的缩写，在 10.4.2 中有一处引用。}} 的创建过程：

# 将 [[#VariableEnvironment|变量环境组件]]设置为[[#the-global-environment|全局环境]]。
# 将 [[#LexicalEnvironment|词法环境组件]]设置为[[#the-global-environment|全局环境]]。
# 将 [[#ThisBinding|this绑定]]设置为[[ES5/builtins#x15.1|全局对象]]。

=== {{anchor|x10.4.2}}进入 eval 代码 ===
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.4.2}}

当控制流进入 [[#eval-code|eval代码]] 的执行环境时，执行以下步骤：

# 如果没有调用环境，或者 [[#eval-code|eval代码]] 并非通过直接调用 [[ES5/builtins#x15.1.2.1.1|eval]] 函数来解释执行的 {{extra note||这里的“直接”表示使用“eval”这个标识符直接解析得到的eval函数，它是一个引用类型。经过其它运算得到的eval函数不属于“直接”的范畴。}}，则 
## 按（[[#x10.4.1.1|10.4.1.1]]）描述的初始化全局执行环境的方案，以 [[#eval-code|eval代码]] 作为 '''C''' {{extra note||ECMA脚本的全局执行环境}} 来初始化执行环境。
# 否则 
## 将 [[#ThisBinding|this 绑定组件]] 设置为当前执行环境下的 [[#ThisBinding|this 绑定组件]]。
## 将 [[#LexicalEnvironment|词法环境组件]] 设置为当前执行环境下的 [[#LexicalEnvironment|词法环境组件]]。
## 将 [[#VariableEnvironment|变量环境组件]] 设置为当前执行环境下的 [[#VariableEnvironment|变量环境组件]]。
# 如果 [[#eval-code|eval 代码]]是[[#strict-mode-code|严格模式下的代码]]，则 
## 令 <var>strictVarEnv</var> 为以词法环境为参数调用 [[#NewDeclarativeEnvironment|NewDeclarativeEnvironment]] 得到的结果。
## 设置 [[#LexicalEnvironment|词法环境组件]] 为 <var>strictVarEnv</var>。
## 设置 [[#VariableEnvironment|变量环境组件]] 为 <var>strictVarEnv</var>。
# 按 [[#x10.5|10.5]] 描述的方案，使用 [[#eval-code|eval代码]] 执行[[#declaration-binding-instantiation|声明式绑定初始化]]化步骤。


==== {{anchor|x10.4.2.1}}严格模式下的限制 ====
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.4.2.1}}

如果调用环境的代码或 [[#eval-code|eval 代码]]是[[#strict-mode-code|严格模式下的代码]]，则 [[ES5/builtins#x15.1.2.1.1|eval]] 代码不能在调用环境的 [[#VariableEnvironment|变量环境组件]] 中[[#declaration-binding-instantiation|初始化变量及函数绑定]]。与之相对的，变量及函数绑定将在一个新的 [[#VariableEnvironment|变量环境组件]] 中被初始化，该 [[#VariableEnvironment|变量环境组件]] 仅可被 [[#eval-code|eval 代码]]访问。


=== {{anchor|x10.4.3}}{{anchor|entering-function-code}}进入函数代码 ===
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.4.3}}

当控制流根据一个函数对象 <var>F</var>、调用者提供的 <var>thisArg</var> 以及调用者提供的 <var>argumentList</var>，进入[[#function-code|函数代码]]的执行环境时，执行以下步骤： {{question||虽然ES5中没有找到定义，但builtin（第15章）的方法和函数在进入时候采取和严格模式相同的 this 绑定 处理方案。即，传入的 null 或 undefined 不会被全局对象取代，也不会被 ToObject 。}}

# 如果[[#function-code|函数代码]]是[[#strict-mode-code|严格模式下的代码]]，设 [[#ThisBinding|this 绑定]] 为 <var>thisArg</var>。
# 否则如果 <var>thisArg</var> 是 '''null''' 或 '''undefined'''，则设 [[#ThisBinding|this 绑定]] 为[[ES5/builtins#x15.1|全局对象]]。 {{v8|https://github.com/v8/v8/blob/3.22/src/execution.cc#L169|}}
# 否则如果 [[ES5/types#Type|Type]](<var>thisArg</var>) 的结果不为 '''Object'''，则设 [[#ThisBinding|this 绑定]] 为 [[ES5/conversion#to-object|ToObject]](<var>thisArg</var>)。
# 否则设 [[#ThisBinding|this 绑定]] 为 <var>thisArg</var>。
# 以 <var>F</var> 的 [[ES5/types#Scope|<nowiki>[[Scope]]</nowiki>]] 内部属性为参数调用 [[#NewDeclarativeEnvironment|NewDeclarativeEnvironment]]，并令 <var>localEnv</var> 为调用的结果。
# 设 [[#LexicalEnvironment|词法环境组件]] 为 <var>localEnv</var>。
# 设 [[#VariableEnvironment|变量环境组件]] 为 <var>localEnv</var>。
# 令 <var>code</var> 为 <var>F</var> 的 [[ES5/types#Code|<nowiki>[[Code]]</nowiki>]] 内部属性的值。
# 按 [[#declaration-binding-instantiation|10.5]] 描述的方案，使用[[#function-code|函数代码]] <var>code</var> 和 <var>argumentList</var> 执行[[#declaration-binding-instantiation|声明式绑定初始化]]化步骤。


== {{anchor|x10.5}}{{anchor|declaration-binding-instantiation}}声明式绑定初始化 ==
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.5}}
{{test262|http://hg.ecmascript.org/tests/test262/file/f2b232b08824/test/suite/ch10/10.5}}

每个执行环境都有一个关联的 [[#VariableEnvironment|变量环境组件]]。当在一个执行环境下评估一段 ECMA 脚本时，变量和函数定义会以绑定的形式添加到这个 [[#VariableEnvironment|变量环境组件]] 的[[#environment-record|环境记录]]中。对于[[#function-code|函数代码]]，参数也同样会以绑定的形式添加到这个 [[#VariableEnvironment|变量环境组件]] 的[[#environment-record|环境记录]]中。

选择使用哪一个、哪一类型的[[#environment-record|环境记录]]来绑定定义，是由执行环境下执行的 ECMA 脚本的类型决定的，而其它部分的逻辑是相同的。当进入一个执行环境时，会按以下步骤在 [[#VariableEnvironment|变量环境组件]] 上创建绑定，其中使用到调用者提供的代码设为 <var>code</var>，如果执行的是[[#function-code|函数代码]]，则设[[ES5/types#List|参数列表]]为 <var>args</var>：

# 令 <var>env</var> 为当前运行的执行环境的[[#VariableEnvironment|变量环境组件]]的[[#environment-record|环境记录项]]。
# 如果 <var>code</var> 是 [[#eval-code|eval 代码]]，则令 <var>configurableBindings</var> 为 '''true'''，否则令 <var>configurableBindings</var> 为 '''false'''。 {{extra note||非严格模式下，局部eval中执行var语句或函数定义语句可以在eval所在的作用域中的变量环境组件里添加这些变量，这些被eval临时定义的变量是可以被delete语句删除的。}}
# 如果代码是[[#strict-mode-code|严格模式下的代码]]，则令 <var>strict</var> 为 '''true'''，否则令 <var>strict</var> 为 '''false'''。
# 如果代码为[[#function-code|函数代码]]，则：
## 令 <var>func</var> 为通过 [[ES5/types#Call|<nowiki>[[Call]]</nowiki>]] 内部属性初始化 <var>code</var> 的执行的函数对象。令 <var>names</var> 为 <var>func</var> 的 [[ES5/types#FormalParameters|<nowiki>[[FormalParameters]]</nowiki>]] 内部属性的值。
## 令 <var>argCount</var> 为 <var>args</var> 中元素的数量。
## 令 <var>n</var> 为数值 '''0'''。
## 按列表顺序遍历 <var>names</var>，对于每一个字符串 <var>argName</var>：
### 令 <var>n</var> 的值为 <var>n</var> 当前值加 '''1'''。
### 如果 <var>n</var> 大于 <var>argCount</var>，则令 <var>v</var> 为 '''undefined'''，否则令 <var>v</var> 为 <var>args</var> 中的第 <var>n</var> 个元素。
### 以 <var>argName</var> 为参数，调用 <var>env</var> 的 [[#HasBinding|HasBinding]] 具体方法，并令 <var>argAlreadyDeclared</var> 为调用的结果。
### 如果 <var>argAlreadyDeclared</var> 的值为 '''false'''，以 <var>argName</var> 为参数调用 <var>env</var> 的 [[#CreateMutableBinding|CreateMutableBinding]] 具体方法。
### 以 <var>argName</var>、<var>v</var> 和 <var>strict</var> 为参数，调用 <var>env</var> 的 [[#SetMutableBinding|SetMutableBinding]] 具体方法。
# 按源码顺序遍历 <var>code</var>，对于每一个 [[ES5/functions#FunctionDeclaration|FunctionDeclaration]] <var>f</var>：{{extra note||函数定义（语句形式）是在代码执行之前被处理的}}
## 令 <var>fn</var> 为 [[ES5/functions#FunctionDeclaration|FunctionDeclaration]] <var>f</var> 中的 ''[[ES5/lexical#Identifier|Identifier]]''。
## 按[[ES5/functions|第 13 章]]中所述的步骤初始化 [[ES5/functions#FunctionDeclaration|FunctionDeclaration]] <var>f</var> ，并令 <var>fo</var> 为初始化的结果。
## 以 <var>fn</var> 为参数，调用 <var>env</var> 的 [[#HasBinding|HasBinding]] 具体方法，并令 <var>argAlreadyDeclared</var> 为调用的结果。
## 如果 <var>argAlreadyDeclared</var> 的值为 '''false'''，以 <var>fn</var> 和 <var>configurableBindings</var> 为参数调用 <var>env</var> 的 [[#CreateMutableBinding|CreateMutableBinding]] 具体方法。
## 否则如果 <var>env</var> 是全局环境的[[#environment-record|环境记录]]对象，则：
### 令 <var>go</var> 为全局对象。
### 以 <var>fn</var> 为参数，调用 <var>go</var> 和 [[ES5/types#GetProperty|<nowiki>[[GetProperty]]</nowiki>]] 内部方法，并令 <var>existingProp</var> 为调用的结果。
### 如果 <var>existingProp</var>.[[ES5/types#Configurable|<nowiki>[[Configurable]]</nowiki>]] 的值为 '''true'''，则：
#### 以 <var>fn</var>、由 {<nowiki>[[Value]]</nowiki>: '''undefined''', <nowiki>[[Writable]]</nowiki>: '''true''', <nowiki>[[Enumerable]]</nowiki>: '''true''', <nowiki>[[Configurable]]</nowiki>: <var>configurableBindings</var> } 组成的[[ES5/types#property-descriptor|属性描述符]]和 '''true''' 为参数，调用 <var>go</var> 的 [[ES5/types#DefineOwnProperty|<nowiki>[[DefineOwnProperty]]</nowiki>]] 内部方法。
### 否则如果 [[ES5/types#IsAccessorDescriptor|IsAccessorDescriptor]](<var>existingProp</var>) 的结果为真，或 <var>existingProp</var> 的特性中没有 {<nowiki>[[Writable]]</nowiki>: '''true''', <nowiki>[[Enumerable]]</nowiki>: '''true'''}，则：
#### 抛出一个 '''TypeError''' 异常。
##以 <var>fn</var>、<var>fo</var> 和 <var>strict</var> 为参数，调用 <var>env</var> 的 {{toanchor|SetMutableBinding}} 具体方法。
# 以 '''"arguments"''' 为参数，调用 <var>env</var> 的 {{toanchor|HasBinding}} 具体方法，并令 <var>argumentsAlreadyDeclared</var> 为调用的结果。
# 如果 <var>code</var> 是[[#function-code|函数代码]]，并且 <var>argumentsAlreadyDeclared</var> 为 '''false'''，则：
## 以 <var>fn</var>、<var>names</var>、<var>args</var>、<var>env</var> 和 <var>strict</var> 为参数，调用 {{toanchor|CreateArgumentsObject}} 抽象运算函数，并令 <var>argsObj</var> 为调用的结果。
## 如果 <var>strict</var> 为 '''true'''，则：
### 以字符串'''"arguments"'''为参数，调用 <var>env</var> 的 [[#CreateImmutableBinding|CreateImmutableBinding]] 具体方法。
### 以字符串 '''"arguments"''' 和 <var>argsObj</var> 为参数，调用 <var>env</var> 的 [[#InitializeImmutableBinding|InitializeImmutableBinding]] 具体函数。
## 否则：
### 以字符串 '''"arguments"'''为参数，调用 <var>env</var> 的 {{toanchor|CreateMutableBinding}} 具体方法。
### 以字符串'''"arguments"'''、<var>argsObj</var> 和 '''false''' 为参数，调用 <var>env</var> 的 {{toanchor|SetMutableBinding}} 具体函数。
# 按源码顺序遍历 <var>code</var>，对于每一个 ''[[ES5/statements#VariableDeclaration|VariableDeclaration]]'' 和 ''[[ES5/statements#VariableDeclarationNoIn|VariableDeclarationNoIn]]'' 表达式作为 <var>d</var> 执行：{{extra note||var定义变量是在代码执行之前被处理的}}
## 令 <var>dn</var> 为 <var>d</var> 中的[[ES5/lexical#x7.6|标识符]]。
## 以 <var>dn</var> 为参数，调用 <var>env</var> 的 {{toanchor|HasBinding}} 具体方法，并令 <var>varAlreadyDeclared</var> 为调用的结果。
## 如果 <var>varAlreadyDeclared</var> 为 '''false'''，则：
### 以 <var>dn</var> 和 <var>configurableBindings</var> 为参数，调用 <var>env</var> 的 {{toanchor|CreateMutableBinding}} 具体方法。
### 以 <var>dn</var>、'''undefined''' 和 <var>strict</var> 为参数，调用 <var>env</var> 的 {{toanchor|SetMutableBinding}} 具体方法。


== {{anchor|x10.6}}{{anchor|CreateArgumentsObject}}创建 Arguments 对象 ==
{{eng ver|http://ecma-international.org/ecma-262/5.1/#sec-10.6}}
{{test262|http://hg.ecmascript.org/tests/test262/file/f2b232b08824/test/suite/ch10/10.6}}

当控制器进入到[[#function-code|函数代码]]的执行环境时，将创建一个 '''arguments''' 对象（透过 [[#x10.5|10.5]] 指定的方式），除非它作为[[ES5/lexical#x7.6|标识符]] '''arguments''' 出现在该函数的形参列表中，或者是该函数代码内部的变量声明[[ES5/lexical#x7.6|标识符]]或函数声明[[ES5/lexical#x7.6|标识符]]。

'''arguments''' 对象通过调用抽象方法 '''CreateArgumentsObject''' 创建，调用时将以下参数传入：<var>func</var>、<var>names</var>、<var>args</var>、<var>env</var>、<var>strict</var>。将要执行的函数对象作为 <var>func</var> 参数，将该函数的所有形参名加入一个[[ES5/types#List|列表]]，称为 <var>names</var> 参数，将所有传给内部方法 [[ES5/types#Call|<nowiki>[[Call]]</nowiki>]] 的实际参数，称为 <var>args</var> 参数，将该[[#function-code|函数代码]]的变量环境称为 <var>env</var> 参数，将该[[#function-code|函数代码]]是否为[[#strict-mode-code|严格代码]]作为 <var>strict</var> 参数。当 '''CreateArgumentsObject''' 调用时，按照以下步骤执行：

# 令 <var>len</var> 为参数 <var>args</var> 的元素个数。
# 令 <var>obj</var> 为一个新建的 ECMAScript 对象。
# 按照 [[ES5/types#object-internal-methods|8.12]] 章节中的规范去设定 <var>obj</var> 对象的所有内部方法。
# 将 <var>obj</var> 对象的内部属性 [[ES5/types#Class|<nowiki>[[Class]]</nowiki>]] 设置为 '''"Arguments"'''。
# 令 <var>Object</var> 为标准的内置对象的构造函数（[[ES5/builtins#object-objects|15.2.2]]）{{question||这个步骤是在干嘛？}}。
# 将 <var>obj</var> 对象的内部属性 [[ES5/types#Prototype|<nowiki>[[Prototype]]</nowiki>]] 设置为标准的内置对象的原型对象。
# 调用 <var>obj</var> 的内部方法 [[ES5/types#DefineOwnProperty|<nowiki>[[DefineOwnProperty]]</nowiki>]]，将 '''"length"''' 传递进去，[[ES5/types#property-descriptor|属性描述符]]为：{<nowiki>[[Value]]</nowiki>: <var>len</var>, <nowiki>[[Writable]]</nowiki>: '''true''', <nowiki>[[Enumerable]]</nowiki>: '''false''', <nowiki>[[Configurable]]</nowiki>: '''true'''}，参数为 '''false'''。
# 令 <var>map</var> 为表达式 '''new Object()''' 创建的对象，就是名为 '''Object''' 的[[ES5/builtins#object-objects|标准的内置构造函数]]。
# 令 <var>mappedNames</var> 为一个空的[[ES5/types#List|列表]]。
# 令 <var>indx</var> = <var>len</var> - '''1'''
# 当 <var>indx</var> >= '''0''' 的时候，重复此过程：
## 令 <var>val</var> 为 <var>args</var>（维度从 0 开始的列表）的第 <var>indx</var> 维度所在的元素。
## 调用 <var>obj</var> 的内部方法 [[ES5/types#DefineOwnProperty|<nowiki>[[DefineOwnProperty]]</nowiki>]]，将 [[ES5/conversion#to-string|ToString]](<var>indx</var>) 传递进去，[[ES5/types#property-descriptor|属性描述符]]为：{<nowiki>[[Value]]</nowiki>: <var>val</var>, <nowiki>[[Writable]]</nowiki>: '''true''', <nowiki>[[Enumerable]]</nowiki>: '''true''', <nowiki>[[Configurable]]</nowiki>: '''true'''}，参数为 '''false'''。
## 如果 <var>indx</var> 小于 <var>names</var> 的元素个数，则
### 令 <var>name</var> 为 <var>names</var>（维度从 0 开始的列表）的第 <var>indx</var> 维度所在的元素。 
### 如果 <var>strict</var> 值为 '''false'''，且 <var>name</var> 不是一个 <var>mappedNames</var> 元素，则 
#### 将 <var>name</var> 添加到 <var>mappedNames</var> 列表中，作为它的一个元素 
#### 令 <var>g</var> 为调用抽象操作 {{toanchor|MakeArgGetter}} 的结果，其参数为 <var>name</var> 和 <var>env</var>。
#### 令 <var>p</var> 为调用抽象操作 {{toanchor|MakeArgSetter}} 的结果，其参数为 <var>name</var> 和 <var>env</var>。
#### 调用 <var>map</var> 对象的内部方法 [[ES5/types#DefineOwnProperty|<nowiki>[[DefineOwnProperty]]</nowiki>]]，将 [[ES5/conversion#to-string|ToString]](<var>indx</var>) 传递进去，[[ES5/types#property-descriptor|属性描述符]]为：{<nowiki>[[Set]]</nowiki>: <var>p</var>, <nowiki>[[Get]]</nowiki>: <var>g</var>, <nowiki>[[Configurable]]</nowiki>: '''true'''}，参数为 '''false'''。
## 令 <var>indx</var> = <var>indx</var> - '''1'''
# 如果 <var>mappedNames</var> 不为空，则 
## 将 <var>obj</var> 对象的内部属性 [[ES5/types#ParameterMap|<nowiki>[[ParameterMap]]</nowiki>]] 设置为 <var>map</var>。
## 将 <var>obj</var> 对象的内部方法 [[ES5/types#Get|<nowiki>[[Get]]</nowiki>]]、[[ES5/types#GetOwnProperty|<nowiki>[[dGetOwnProperty]]</nowiki>]]、[[ES5/types#DefineOwnProperty|<nowiki>[[DefineOwnProperty]]</nowiki>]]、[[ES5/types#Delete|<nowiki>[[Delete]]</nowiki>]] 按下面给出的定义进行设置。
# 如果 <var>strict</var> 值为 '''false'''，则 {{v8|https://github.com/v8/v8/blob/3.22/src/builtins.cc#L1089-L1093|}}
## 调用 <var>obj</var> 对象的内部方法 [[ES5/types#DefineOwnProperty|<nowiki>[[DefineOwnProperty]]</nowiki>]]，将 '''"callee"''' 传递进去，[[ES5/types#property-descriptor|属性描述符]]为：{<nowiki>[[Value]]</nowiki>: <var>func</var>, <nowiki>[[Writable]]</nowiki>: '''true''', <nowiki>[[Enumerable]]</nowiki>: '''false''', <nowiki>[[Configurable]]</nowiki>: '''true'''}，参数为 '''false'''。
# 否则，<var>strict</var> 值为 '''true'''，那么 
## 令 <var>thrower</var> 为 [[ES5/functions#ThrowTypeError|<nowiki>[[ThrowTypeError]]</nowiki>]] 函数对象（[[ES5/functions#ThrowTypeError|13.2.3]]）。
## 调用 <var>obj</var> 对象的内部方法 [[ES5/types#DefineOwnProperty|<nowiki>[[DefineOwnProperty]]</nowiki>]]，将 '''"caller"''' 传递进去，[[ES5/types#property-descriptor|属性描述符]]为：{<nowiki>[[Get]]</nowiki>: <var>thrower</var>, <nowiki>[[Set]]</nowiki>: <var>thrower</var>, <nowiki>[[Enumerable]]</nowiki>: '''false''', <nowiki>[[Configurable]]</nowiki>: '''false'''}，参数为 '''false'''。
## 调用 <var>obj</var> 对象的内部方法 [[ES5/types#DefineOwnProperty|<nowiki>[[DefineOwnProperty]]</nowiki>]]，将 '''"callee"''' 传递进去，[[ES5/types#property-descriptor|属性描述符]]为：{<nowiki>[[Get]]</nowiki>: <var>thrower</var>, <nowiki>[[Set]]</nowiki>: <var>thrower</var>, <nowiki>[[Enumerable]]</nowiki>: '''false''', <nowiki>[[Configurable]]</nowiki>: '''false'''}，参数为 '''false'''。
# 返回 <var>obj</var>。

{{anchor|MakeArgGetter}}抽象操作 '''MakeArgGetter''' 以字符串 <var>name</var> 和环境记录 <var>env</var> 作为参数被调用时，会创建一个函数对象，当执行完后，会返回在 <var>env</var> 中绑定的 <var>name</var> 的值。执行步骤如下：

# 令 <var>body</var> 为字符 '''"return "'''、<var>name</var>、'''";"''' 的连接字符串。
# 返回一个按照 [[ES5/functions#x13.2|13.2]] 章节中描述的方式创建的函数对象，它不需要形参列表，以 <var>body</var> 作为它的 ''[[ES5/functions#FunctionBody|FunctionBody]]''，以 <var>env</var> 作为它的 ''Scope''，并且 <var>strict</var> 值为 '''true'''。

{{anchor|MakeArgSetter}}抽象操作 '''MakeArgSetter''' 以字符串 <var>name</var> 和环境记录 <var>env</var> 作为参数被调用时，会创建一个函数对象，当执行完后，会给在 <var>env</var> 中绑定的 <var>name</var> 设置一个值。执行步骤如下：

# 令 <var>param</var> 为 <var>name</var> 和字符串 '''"_arg"''' 的连接字符串。
# 令 <var>body</var> 为字符串 '''"<name>=<param>;"'''；将 '''<name>''' 替换为 <var>name</var> 的值，将 '''<param>''' 替换为 <var>param</var> 的值。
# 返回一个按照 [[ES5/functions#13.2|13.2]] 章节中描述的方式创建的函数对象，以一个只包含字符串 <var>param</var> 的[[ES5/types#List|列表]]作为它的形参，以 <var>body</var> 作为它的函数体（''[[ES5/functions#FunctionBody|FunctionBody]]''），以 <var>env</var> 作为它的 [[ES5/functions#13.2|<var>Scope</var>]]，并且 [[ES5/functions#13.2|<var>strict</var>]] 值为 '''true'''。

{{anchor|arguments-Get}}当 '''arguments''' 对象的内部方法 '''<nowiki>[[Get]]</nowiki>''' 在一个非严格模式下带有形参的函数中，在一个属性名为 <var>P</var> 的条件下被调用时，其执行步骤如下：

# 令 <var>map</var> 为 '''arguments''' 对象的内部属性 [[ES5/types#ParameterMap|<nowiki>[[ParameterMap]]</nowiki>]]。
# 令 <var>isMapped</var> 为 <var>map</var> 对象的内部方法 [[ES5/types#GetOwnProperty|<nowiki>[[GetOwnPropery]]</nowiki>]] 传入参数 <var>P</var> 的执行结果。
# 如果 <var>isMapped</var> 值为 '''undefined'''，则 
## 令 <var>v</var> 为 '''arguments''' 对象的内部默认的 [[ES5/types#Get|<nowiki>[[Get]]</nowiki>]] 方法（[[ES5/types#Get-impl|8.12.3]]），传入参数 <var>P</var> 的执行结果。
## 如果 <var>P</var> 为 '''"caller"'''，且 <var>v</var> 为[[#strict-mode-code|严格模式]]下的 '''Function''' 对象，则抛出一个 '''TypeError''' 的异常。
## 返回 <var>v</var>。
# 否则，<var>map</var> 包含一个 <var>P</var> 的形参映射表。
## 返回 <var>map</var> 对象的内部方法 [[ES5/types#Get|<nowiki>[[Get]]</nowiki>]] 传入参数 <var>P</var> 的执行结果。

{{anchor|arguments-GetOwnProperty}}当 '''arguments''' 对象的内部方法 '''<nowiki>[[GetOwnProperty]]</nowiki>''' 在一个非严格模式下带有形参的函数中，在一个属性名为 <var>P</var> 的条件下被调用时，其执行步骤如下： 

# 令 <var>desc</var> 为 '''arguments''' 对象的内部方法 [[ES5/types#GetOwnProperty|<nowiki>[[GetOwnProperty]]</nowiki>]]（[[ES5/types#GetOwnProperty-impl|8.12.1]]）传入参数 <var>P</var> 的执行结果。
# 如果 <var>desc</var> 为 '''undefined'''，返回 <var>desc</var>。
# 令 <var>map</var> 为 '''arguments''' 对象内部属性 [[ES5/types#ParameterMap|<nowiki>[[ParameterMap]]</nowiki>]] 的值。
# 令 <var>isMapped</var> 为 <var>map</var> 对象的内部方法 [[ES5/types#GetOwnProperty|<nowiki>[[GetOwnPropery]]</nowiki>]] 传入参数 <var>P</var> 的执行结果。
# 如果 <var>isMapped</var> 的值不是 '''undefined'''，则 
## 将 <var>desc</var>.[[ES5/types#Value|<nowiki>[[Value]]</nowiki>]] 的值设置为 <var>map</var> 对象的内部方法 [[ES5/types#Get|<nowiki>[[Get]]</nowiki>]] 传入参数 <var>P</var> 的执行结果。
# 返回 <var>desc</var>。

{{anchor|arguments-DefineOwnProperty}}当 '''arguments''' 对象的内部方法 '''<nowiki>[[DefineOwnProperty]]</nowiki>''' 在一个非严格模式下带有形参的函数中，在一个属性名为 <var>P</var>，属性描述符为 <var>Desc</var>，布尔标志为 <var>Throw</var> 的条件下被调用时，其执行步骤如下： 

# 令 <var>map</var> 为 '''arguments''' 对象的内部属性 [[ES5/types#ParameterMap|<nowiki>[[ParameterMap]]</nowiki>]] 的值。
# 令 <var>isMapped</var> 为 <var>map</var> 对象的内部方法 [[ES5/types#GetOwnProperty|<nowiki>[[GetOwnPropery]]</nowiki>]] 传入参数 <var>P</var> 的执行结果。
# 令 <var>allowed</var> 为 '''arguments''' 对象的内部方法 [[ES5/types#DefineOwnProperty|<nowiki>[[DefineOwnPropery]]</nowiki>]]（[[ES5/types#DefineOwnProperty-impl|8.12.9]]）传入参数 <var>P</var>、<var>Desc</var>、'''false''' 的执行结果。
# 如果 <var>allowed</var> 为 '''false'''，则 
## 如果 <var>Throw</var> 为 '''true'''，则抛出一个 '''TypeError''' 的异常，否则，返回 '''false'''。
# 如果 <var>isMapped</var> 的值不为 '''undefined'''，则 
## 如果 [[ES5/types#IsAccessorDescriptor|IsIsAccessorDescriptor]](<var>Desc</var>) 为 '''true'''，则 
### 调用 <var>map</var> 对象的内部方法 [[ES5/types#Delete|<nowiki>[[Delete]]</nowiki>]]，传入 <var>P</var> 和 '''false''' 作为参数。
## 否则 
### 如果 <var>Desc</var>.[[ES5/types#Value|<nowiki>[[Value]]</nowiki>]] 存在，则 
#### 调用 <var>map</var> 对象的内部方法 [[ES5/types#Put|<nowiki>[[Put]]</nowiki>]]，传入 <var>P</var>、<var>Desc</var>.[[ES5/types#Value|<nowiki>[[Value]]</nowiki>]] 和 <var>Throw</var> 作为参数。
### 如果 <var>Desc</var>.[[ES5/types#Writable|<nowiki>[[Writable]]</nowiki>]] 存在，且其值为 '''false'''，则 
#### 调用 <var>map</var> 对象的内部方法 [[ES5/types#Delete|<nowiki>[[Delete]]</nowiki>]]，传入 <var>P</var> 和 '''false''' 作为参数。
# 返回 '''true'''。

{{anchor|arguments-Delete}}当 '''arguments''' 对象的内部方法 '''<nowiki>[[Delete]]</nowiki>''' 在一个非严格模式下带有形参的函数中，在一个属性名为 <var>P</var>，布尔标志为 <var>Throw</var> 的条件下被调用时，其执行步骤如下：

# 令 <var>map</var> 为 '''arguments''' 对象的内部属性 [[ES5/types#ParameterMap|<nowiki>[[ParameterMap]]</nowiki>]] 的值。
# 令 <var>isMapped</var> 为 <var>map</var>  对象的内部方法 [[ES5/types#GetOwnProperty|<nowiki>[[GetOwnPropery]]</nowiki>]] 传入参数 <var>P</var> 的执行结果。
# 令 <var>result</var> 为 '''arguments''' 对象的内部方法 [[ES5/types#Delete|<nowiki>[[Delete]]</nowiki>]]（[[ES5/types#Delete-impl|8.12.7]]）传入参数 <var>P</var> 和 <var>Throw</var> 的执行结果。
# 如果 <var>result</var> 为 '''true'''，且 <var>isMapped</var> 不为 '''undefined'''，则 
## 调用 <var>map</var> 对象的内部方法 [[ES5/types#Delete|<nowiki>[[Delete]]</nowiki>]]，传入 <var>P</var> 和 '''false''' 作为参数。
# 返回 <var>result</var>。

{{note| 非严格模式下的函数，'''arguments''' 对象以数组索引（参见 15.4 的定义）作为数据属性的命名，其数字名字的值少于对应的函数对象初始时的形参数量，它们与绑定在该函数执行环境中对应的参数共享值。这意味着，改变该属性将改变这些对应的、绑定的参数的值，反之亦然。如果其中一个属性被删除然后再对其重定义，或者其中一个属性在某个访问器属性内部被更改，则这种对应关系将被打破。严格模式下的函数，'''arguments''' 对象的属性值就是传入该函数的实际参数的简单拷贝，它们与形参之间的值不存在动态的联动关系。}}

{{note| '''ParameterMap''' 对象和它的属性值被作为说明 '''arguments''' 对象对应绑定参数的装置。'''ParameterMap''' 对象和它的属性值对象不能直接被 ECMAScript 代码访问。作为 ECMAScript 的实现，不需要实际创建或使用这些对象去实现指定的语义。}}

{{note| 严格模式下函数的 '''Arguments''' 对象定义的非可配置的访问器属性，'''"caller"''' 和 '''"callee"'''，在它们被访问时，将抛出一个 '''TypeError''' 的异常。在非严格模式下，'''"callee"''' 属性具有非常明确的意义，'''"caller"''' 属性有一个历史问题，它是否被提供，视为一个由实作环境决定的，在具体的 ECMAScript 实作进行扩展。在严格模式下对这些属性的定义的出现是为了确保它们俩谁也不能在规范的 ECMAScript 实作中以任何方式被定义。}}
